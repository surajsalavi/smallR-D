{"version":3,"file":"vara.umd.production.min.js","sources":["../src/utils/char.ts","../src/types.ts","../src/utils/renderbase.ts","../src/utils/letterpart.ts","../src/utils/letter.ts","../src/utils/line.ts","../src/utils/block.ts","../src/index.ts"],"sourcesContent":["import { VaraFontItem } from '../types';\r\n\r\ninterface VaraCharProps {\r\n    char: string;\r\n    fontItem: VaraFontItem;\r\n    isSpace?: boolean;\r\n}\r\n\r\nlet varaCharId = 0;\r\n\r\nexport default class VaraChar {\r\n    char: string;\r\n    id: number;\r\n    fontItem: VaraFontItem;\r\n    isSpace: boolean;\r\n\r\n    constructor(props: VaraCharProps) {\r\n        this.char = props.char;\r\n        this.fontItem = props.fontItem;\r\n        this.isSpace = props.isSpace ?? false;\r\n\r\n        this.id = varaCharId;\r\n        varaCharId++;\r\n    }\r\n\r\n    getFontItem() {\r\n        return this.fontItem;\r\n    }\r\n\r\n    getId() {\r\n        return this.id;\r\n    }\r\n}\r\n","import Block from \"./utils/block\";\r\nimport Letter from \"./utils/letter\";\r\nimport LetterPart from \"./utils/letterpart\";\r\nimport Line from \"./utils/line\";\r\n\r\nexport type VaraGeneralOptions = {\r\n    fontSize?: number;\r\n    strokeWidth?: number;\r\n    color?: string;\r\n    duration?: number;\r\n    textAlign?: 'left' | 'center' | 'right';\r\n    autoAnimation?: boolean;\r\n    queued?: boolean;\r\n    delay?: number;\r\n    letterSpacing?:\r\n        | {\r\n              [x: string]: number;\r\n          }\r\n        | number;\r\n    breakWord?: boolean;\r\n    width?: number;\r\n    lineHeight?: number;\r\n};\r\n\r\nexport type VaraTextOptions = VaraGeneralOptions & {\r\n    id?: string | number | false;\r\n    x?: number;\r\n    y?: number;\r\n    absolutePosition?: boolean;\r\n};\r\n\r\nexport type VaraText = VaraTextOptions & {\r\n    text: string | string[];\r\n};\r\n\r\nexport type VaraFontItem = {\r\n    paths: Array<{\r\n        w: number;\r\n        h: number;\r\n        my: number;\r\n        mx: number;\r\n        dx: number;\r\n        d: string;\r\n        pl: number;\r\n    }>;\r\n    w: number;\r\n};\r\n\r\nexport type ObjectKeys<T> = T extends object\r\n    ? (keyof T)[]\r\n    : T extends number\r\n    ? []\r\n    : T extends Array<any> | string\r\n    ? string[]\r\n    : never;\r\n\r\nexport const BLOCK_COMPOSITION = [\"block\",\"line\",\"letter\",\"letterPart\"] as const;\r\n\r\nexport type BlockComposition = typeof BLOCK_COMPOSITION;\r\n\r\nexport type BlockName = BlockComposition[number];\r\n\r\nexport type Blocks = Block | Line | Letter | LetterPart;\r\n\r\nexport type BlockMapped = {\r\n    \"block\" : Block,\r\n    \"line\": Line,\r\n    \"letter\": Letter,\r\n    \"letterPart\": LetterPart\r\n}","import { BlockMapped, BlockName, Blocks, BLOCK_COMPOSITION } from '../types';\r\n\r\ninterface RenderItemProps {\r\n    ctx: CanvasRenderingContext2D;\r\n    parent?: Blocks;\r\n}\r\n\r\nexport default class RenderBase {\r\n    protected ctx: CanvasRenderingContext2D;\r\n    parent?: Blocks | null;\r\n    name: BlockName;\r\n\r\n    constructor(props: RenderItemProps) {\r\n        this.ctx = props.ctx;\r\n        this.parent = props.parent ?? null;\r\n        this.name = 'block';\r\n    }\r\n\r\n    getParent<T extends BlockName>(\r\n        parentName: T,\r\n        current: Blocks\r\n    ): BlockMapped[T] | false {\r\n        const parentIndex = BLOCK_COMPOSITION.indexOf(parentName);\r\n        const currentItemIndex = BLOCK_COMPOSITION.indexOf(this.name);\r\n        if (parentIndex < currentItemIndex) {\r\n            if (current.name === parentName) {\r\n                return current as BlockMapped[T];\r\n            } else {\r\n                if (current.parent)\r\n                    return this.getParent(parentName, current?.parent);\r\n                else return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n","import { BlockName } from '../types';\r\nimport Block from './block';\r\nimport Letter from './letter';\r\nimport RenderBase from './renderbase';\r\n\r\nexport interface LetterPartProps {\r\n    x: number;\r\n    y: number;\r\n    path: string;\r\n    pathLength: number;\r\n    dashOffset: number;\r\n    width: number;\r\n    ctx: CanvasRenderingContext2D;\r\n    parent: Letter;\r\n}\r\n\r\nexport default class LetterPart extends RenderBase {\r\n    x: number;\r\n    y: number;\r\n    path: string;\r\n    pathLength: number;\r\n    dashOffset: number;\r\n    width: number;\r\n    name: BlockName;\r\n    rootBlock: Block;\r\n\r\n    constructor(props: LetterPartProps) {\r\n        super(props);\r\n\r\n        this.x = props.x;\r\n        this.y = props.y;\r\n        this.path = props.path;\r\n        this.pathLength = props.pathLength;\r\n        this.dashOffset = props.dashOffset;\r\n        this.width = props.width;\r\n\r\n        this.name = 'letterPart';\r\n\r\n        this.rootBlock = this.getParent('block', this) as Block;\r\n    }\r\n\r\n    /**\r\n     * Paints the path\r\n     */\r\n    paint() {\r\n        this.ctx.save();\r\n        this.ctx.stroke(\r\n            new Path2D(this.processPath(this.path, this.x, this.y))\r\n        );\r\n        this.ctx.restore();\r\n    }\r\n\r\n    /**\r\n     * Increments the dashOffset and then paints the path.\r\n     */\r\n    draw(delta: number) {\r\n        const pathDuration =\r\n            ((this.pathLength / this.rootBlock.totalPathLength) *\r\n                this.rootBlock.options.duration) /\r\n            1000;\r\n\r\n        const speed = this.pathLength / pathDuration;\r\n\r\n        this.ctx.save();\r\n        this.ctx.lineDashOffset = 1;\r\n        this.ctx.setLineDash([this.dashOffset, this.pathLength + 1]);\r\n        this.dashOffset += speed * delta;\r\n        this.paint();\r\n        this.ctx.restore();\r\n    }\r\n\r\n    processPath(path: string, x = 0, y = 0) {\r\n        let svgPath = path.split('');\r\n        svgPath[2] = x + '';\r\n        svgPath[4] = y + '';\r\n        return svgPath.join('');\r\n    }\r\n}\r\n","import { BlockName } from '../types';\r\nimport Block from './block';\r\nimport VaraChar from './char';\r\nimport LetterPart, { LetterPartProps } from './letterpart';\r\nimport Line from './line';\r\nimport RenderBase from './renderbase';\r\n\r\nexport interface LetterProps {\r\n    x: number;\r\n    y: number;\r\n    width: number;\r\n    ctx: CanvasRenderingContext2D;\r\n    parent: Line;\r\n    character: VaraChar;\r\n}\r\n\r\nlet letterId = 0;\r\n\r\nexport default class Letter extends RenderBase {\r\n    x: number;\r\n    y: number;\r\n    width: number;\r\n    character: VaraChar;\r\n    id: number;\r\n\r\n    parts: LetterPart[];\r\n\r\n    drawnParts: LetterPart[];\r\n    name: BlockName;\r\n\r\n    rootBlock: Block;\r\n\r\n    constructor(props: LetterProps) {\r\n        super(props);\r\n\r\n        this.x = props.x;\r\n        this.y = props.y;\r\n        this.width = props.width;\r\n        this.parts = [];\r\n        this.drawnParts = [];\r\n        this.name = 'letter';\r\n\r\n        this.character = props.character;\r\n\r\n        this.id = letterId;\r\n        letterId++;\r\n\r\n        this.rootBlock = this.getParent('block', this) as Block;\r\n    }\r\n\r\n    setPosition(x: number, y: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    /**\r\n     * Add a new part to the queue\r\n     * @param part The part to be added\r\n     */\r\n    addPart(part: Omit<LetterPartProps, 'ctx' | 'parent'>) {\r\n        this.parts.push(\r\n            new LetterPart({\r\n                ...part,\r\n                ctx: this.ctx,\r\n                parent: this,\r\n            })\r\n        );\r\n\r\n        // Update the total path length stored in the main block.\r\n        if (this.rootBlock) {\r\n            this.rootBlock.modifyPathLength(part.pathLength, 'increment');\r\n        }\r\n    }\r\n\r\n    setParent(parent: Line) {\r\n        this.parent = parent;\r\n    }\r\n\r\n    isDone() {\r\n        return this.parts.length === 0;\r\n    }\r\n\r\n    /**\r\n     * Remove the first item from the queue. Used when a part has been drawn completely.\r\n     *\r\n     * The removed item is moved to the drawnParts array\r\n     */\r\n    dequeue() {\r\n        const removedItem = this.parts.shift();\r\n        if (removedItem) this.drawnParts.push(removedItem);\r\n    }\r\n\r\n    /**\r\n     * Render the current letter\r\n     * @param rafTime The time value received from requestAnimationFrame\r\n     */\r\n    render(rafTime: number, previousRAFTime: number) {\r\n        this.ctx.save();\r\n        this.ctx.scale(this.rootBlock.scale, this.rootBlock.scale);\r\n        this.ctx.translate(this.x, this.y);\r\n\r\n        const delta = (rafTime - previousRAFTime) / 1000;\r\n\r\n        if (this.parts.length > 0) {\r\n            const part = this.parts[0];\r\n            if (part.dashOffset > part.pathLength) {\r\n                this.dequeue();\r\n            } else {\r\n                part.draw(delta);\r\n            }\r\n        }\r\n\r\n        this.drawnParts.forEach(drawnPart => {\r\n            drawnPart.paint();\r\n        });\r\n\r\n        this.ctx.restore();\r\n    }\r\n\r\n    /**\r\n     * Paints the paths whose animations are complete\r\n     */\r\n    paint() {\r\n        this.ctx.save();\r\n        this.ctx.scale(this.rootBlock.scale, this.rootBlock.scale);\r\n        this.ctx.translate(this.x, this.y);\r\n\r\n        this.drawnParts.forEach(drawnPart => {\r\n            drawnPart.paint();\r\n        });\r\n\r\n        this.ctx.restore();\r\n    }\r\n}\r\n","import Block from './block';\r\nimport Letter, { LetterProps } from './letter';\r\nimport RenderBase from './renderbase';\r\n\r\nexport interface LineProps {\r\n    x: number;\r\n    y: number;\r\n    ctx: CanvasRenderingContext2D;\r\n    parent: Block;\r\n}\r\n\r\nlet lineId = 0;\r\n\r\n/**\r\n * Used to represent a line of text drawn in the canvas.\r\n *\r\n */\r\n\r\nexport default class Line extends RenderBase {\r\n    x: number;\r\n    y: number;\r\n    width: number;\r\n    letters: Letter[];\r\n    drawnLetters: Letter[];\r\n    id: number;\r\n\r\n    constructor(props: LineProps) {\r\n        super(props);\r\n\r\n        this.x = props.x;\r\n        this.y = props.y;\r\n        this.ctx = props.ctx;\r\n\r\n        // This will act as queue of letters\r\n        // Each item is animated one after the other\r\n        this.letters = [];\r\n\r\n        // This will contain all the letters that have already been drawn (animated).\r\n        this.drawnLetters = [];\r\n\r\n        // The name of this class.\r\n        // Name is used for finding a specific parent using the getParent method\r\n        this.name = 'line';\r\n\r\n        this.width = 0;\r\n\r\n        this.id = lineId;\r\n        lineId++;\r\n    }\r\n\r\n    /**\r\n     * Add a new letter to this line\r\n     * @param letter - The letter to be added\r\n     */\r\n    addLetter(letter: Omit<LetterProps, 'ctx' | 'parent'> & { parent?: Line }) {\r\n        // Create the letter\r\n\r\n        const newLetter = new Letter({\r\n            ...letter,\r\n            parent: letter.parent ?? this,\r\n            ctx: this.ctx,\r\n        });\r\n\r\n        // Create all the parts of the letter\r\n        // A letter can have multiple parts.\r\n        // The letter i has two parts, the tittle (dot) and the line part?\r\n\r\n        letter.character.getFontItem().paths.forEach(path => {\r\n            newLetter.addPart({\r\n                path: path.d,\r\n                x: path.mx - path.dx,\r\n                y: -path.my,\r\n                pathLength: path.pl,\r\n                dashOffset: 0,\r\n                width: path.w,\r\n            });\r\n        });\r\n\r\n        this.width += letter.width;\r\n        this.letters.push(newLetter);\r\n\r\n        // Return the newly created letter\r\n        return newLetter;\r\n    }\r\n\r\n    removeLetter(letterId: number) {\r\n        this.letters = this.letters.filter(letter => letter.id !== letterId);\r\n        this.drawnLetters = this.drawnLetters.filter(\r\n            letter => letter.id !== letterId\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Override the letters of this line.\r\n     *\r\n     * Letter states are preserved.\r\n     *\r\n     * @param letters The new letters of the line\r\n     */\r\n    setLetters(letters: Letter[]) {\r\n        this.letters = letters.filter(letter => !letter.isDone());\r\n        this.drawnLetters = letters.filter(letter => letter.isDone());\r\n    }\r\n\r\n    /**\r\n     * Sets the position of the current line\r\n     * @param x X-coordinate, relative to the parent block\r\n     * @param y Y-coordinate, relative to the parent block\r\n     */\r\n    setPosition(x: number, y: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    /**\r\n     * Used to check if all the letters in this line have been drawn.\r\n     */\r\n    isDone() {\r\n        return this.letters.length === 0;\r\n    }\r\n\r\n    /**\r\n     * Returns all the letters in this line including those that are to be animated.\r\n     */\r\n    getAllLetters() {\r\n        return [...this.letters, ...this.drawnLetters];\r\n    }\r\n\r\n    /**\r\n     * Remove the first letter from the queue. Used when a letter has been drawn completely.\r\n     * The removed letter is moved to the drawnLetters array\r\n     */\r\n    private dequeue() {\r\n        const removedItem = this.letters.shift();\r\n        if (removedItem) this.drawnLetters.push(removedItem);\r\n    }\r\n\r\n    /**\r\n     * Render the current line\r\n     * @param rafTime The time value received from requestAnimationFrame\r\n     */\r\n    render(rafTime: number, prevRAFTime: number) {\r\n        this.ctx.save();\r\n\r\n        // Set the position of the line\r\n        this.ctx.translate(this.x, this.y);\r\n\r\n        if (this.letters.length > 0) {\r\n            const currentLetter = this.letters[0];\r\n            currentLetter.render(rafTime, prevRAFTime);\r\n\r\n            // If the current letter is animated, then remove it from the queue and add it to the drawn letters\r\n            if (currentLetter.isDone()) {\r\n                this.dequeue();\r\n            }\r\n        }\r\n\r\n        // Paint all the already animated letters\r\n        // The paint method will draw the line without changing the dashOffset\r\n\r\n        this.drawnLetters.forEach(letter => {\r\n            letter.paint();\r\n        });\r\n\r\n        // Restore canvas state (position)\r\n        this.ctx.restore();\r\n    }\r\n}\r\n","import Vara from '..';\r\nimport { BlockName, VaraText, VaraTextOptions } from '../types';\r\nimport VaraChar from './char';\r\nimport Letter from './letter';\r\nimport Line, { LineProps } from './line';\r\nimport RenderBase from './renderbase';\r\n\r\ninterface BlockProps {\r\n    ctx: CanvasRenderingContext2D;\r\n    options: Required<VaraText>;\r\n    root: Vara;\r\n}\r\n\r\nexport default class Block extends RenderBase {\r\n    x: number;\r\n    y: number;\r\n    width: number;\r\n    height: number;\r\n    scale: number;\r\n\r\n    ctx: CanvasRenderingContext2D;\r\n    previousRAFTime: number;\r\n    lines: Line[];\r\n    drawnLines: Line[];\r\n    totalPathLength: number;\r\n    options: Required<VaraText>;\r\n    text: VaraChar[][];\r\n\r\n    private root: Vara;\r\n    private userDefinedRenderFn: (\r\n        ctx: CanvasRenderingContext2D,\r\n        rafTime: number\r\n    ) => void;\r\n\r\n    name: BlockName;\r\n\r\n    constructor(props: BlockProps) {\r\n        super(props);\r\n\r\n        this.x = props.options.x;\r\n        this.y = props.options.y;\r\n        this.width = props.options.width;\r\n        this.height = 0;\r\n\r\n        this.lines = [];\r\n        this.drawnLines = [];\r\n        this.ctx = props.ctx;\r\n        this.previousRAFTime = 0;\r\n        this.totalPathLength = 0;\r\n        this.text = [];\r\n        this.options = props.options;\r\n\r\n        this.name = 'block';\r\n\r\n        this.root = props.root;\r\n        this.scale = Math.min(1, props.options.fontSize / this.root.scalebase);\r\n\r\n        this.userDefinedRenderFn = () => null;\r\n\r\n        this.initTextToVaraChar();\r\n\r\n        this.generatePositions();\r\n    }\r\n\r\n    // Begin private functions\r\n\r\n    private initTextToVaraChar() {\r\n        if (typeof this.options.text === 'string') {\r\n            this.text = [\r\n                this.options.text.split('').map(\r\n                    letter =>\r\n                        new VaraChar({\r\n                            char: letter,\r\n                            fontItem:\r\n                                this.root.fontCharacters[\r\n                                    letter.charCodeAt(0)\r\n                                ] || this.root.fontCharacters['63'],\r\n                            isSpace: letter === ' ',\r\n                        })\r\n                ),\r\n            ];\r\n        } else if (Array.isArray(this.options.text)) {\r\n            this.text = this.options.text.map(line =>\r\n                line.split('').map(\r\n                    letter =>\r\n                        new VaraChar({\r\n                            char: letter,\r\n                            fontItem:\r\n                                this.root.fontCharacters[\r\n                                    letter.charCodeAt(0)\r\n                                ] || this.root.fontCharacters['63'],\r\n                            isSpace: letter === ' ',\r\n                        })\r\n                )\r\n            );\r\n        } else {\r\n            // TODO: Show warning / error\r\n            this.text = [];\r\n        }\r\n    }\r\n\r\n    private regeneratePositions(\r\n        lines: {\r\n            text: VaraChar[];\r\n            width: number;\r\n        }[]\r\n    ) {\r\n        this.height = 0;\r\n\r\n        let top = this.options.lineHeight;\r\n\r\n        const lettersToSetInLine: Letter[][] = [];\r\n\r\n        lines.forEach((line, lineIndex) => {\r\n            let left = 0;\r\n            let x = 0,\r\n                y = top;\r\n            if (this.options.textAlign === 'center') {\r\n                x = (this.options.width - line.width) / 2;\r\n            }\r\n\r\n            let lineClass = this.getLineAtIndex(lineIndex);\r\n            lineClass.setPosition(x, y);\r\n\r\n            const lettersToSet: Letter[] = [];\r\n\r\n            line.text.forEach(char => {\r\n                if (char.isSpace) {\r\n                    left += char.getFontItem().w;\r\n                } else {\r\n                    let foundLetter = this.getLetterByCharacterId(char.id);\r\n                    if (foundLetter) {\r\n                        foundLetter.setParent(lineClass);\r\n                        foundLetter.setPosition(left, 0);\r\n                        lettersToSet.push(foundLetter);\r\n\r\n                        left += foundLetter.character.getFontItem().w;\r\n                    } else {\r\n                        // TODO: Show meaningful error\r\n                        console.error(\r\n                            `Error - Letter with id ${char.id} not found`\r\n                        );\r\n                    }\r\n                }\r\n            });\r\n            top += this.options.lineHeight;\r\n            this.height += this.options.lineHeight;\r\n\r\n            lettersToSetInLine.push(lettersToSet);\r\n        });\r\n\r\n        this.getLines().forEach((line, lineIndex) => {\r\n            line.setLetters(lettersToSetInLine[lineIndex]);\r\n        });\r\n    }\r\n\r\n    private generatePositions() {\r\n        this.height = 0;\r\n\r\n        const lines = this.generateLineData(this.text);\r\n\r\n        let top = this.options.lineHeight;\r\n        lines.forEach(line => {\r\n            let left = 0;\r\n            let x = 0,\r\n                y = top;\r\n            if (this.options.textAlign === 'center') {\r\n                x = (this.options.width - line.width) / 2;\r\n            }\r\n\r\n            const lineClass = this.addLine({\r\n                x,\r\n                y,\r\n            });\r\n\r\n            line.text.forEach(letter => {\r\n                const currentLetter = letter.getFontItem();\r\n\r\n                lineClass.addLetter({\r\n                    x: left,\r\n                    y: 0,\r\n                    width: currentLetter.w,\r\n                    character: letter,\r\n                });\r\n\r\n                left += currentLetter.w;\r\n            });\r\n            top += this.options.lineHeight;\r\n            this.height += this.options.lineHeight;\r\n        });\r\n    }\r\n\r\n    private generateLineData(lines: VaraChar[][]) {\r\n        const returnData: {\r\n            text: VaraChar[];\r\n            width: number;\r\n        }[] = [\r\n            {\r\n                text: [],\r\n                width: 0,\r\n            },\r\n        ];\r\n\r\n        const wordSplittedLines: VaraChar[][][] = [];\r\n\r\n        lines.forEach(line => {\r\n            let l: VaraChar[][] = [[]];\r\n            line.forEach(letter => {\r\n                if (letter.isSpace) {\r\n                    l.push([]);\r\n                } else {\r\n                    l[l.length - 1].push(letter);\r\n                }\r\n            });\r\n            wordSplittedLines.push(l);\r\n        });\r\n\r\n        wordSplittedLines.forEach(line => {\r\n            let spaceWidth = 0;\r\n            line.forEach(word => {\r\n                let wordWidth = 0;\r\n\r\n                word.forEach(letter => {\r\n                    const currentLetter = letter.getFontItem();\r\n\r\n                    let pathPositionCorrection = currentLetter.paths.reduce(\r\n                        (a, c) => a + c.mx - c.dx,\r\n                        0\r\n                    );\r\n                    wordWidth +=\r\n                        (currentLetter.w + pathPositionCorrection) * this.scale;\r\n                });\r\n\r\n                const spaceChar = new VaraChar({\r\n                    char: ' ',\r\n                    fontItem: this.root.fontCharacters['32'],\r\n                    isSpace: true,\r\n                });\r\n\r\n                if (\r\n                    (returnData[returnData.length - 1]?.width ?? 0) +\r\n                        wordWidth +\r\n                        spaceWidth +\r\n                        this.options.x >\r\n                    this.options.width\r\n                ) {\r\n                    returnData.push({\r\n                        text: [...word, spaceChar],\r\n                        width: wordWidth,\r\n                    });\r\n                    spaceWidth = 0;\r\n                } else {\r\n                    returnData[returnData.length - 1] = {\r\n                        text: [\r\n                            ...returnData[returnData.length - 1].text,\r\n                            ...word,\r\n                            spaceChar,\r\n                        ],\r\n                        width:\r\n                            returnData[returnData.length - 1].width + wordWidth,\r\n                    };\r\n                    spaceWidth += spaceChar.getFontItem().w;\r\n                }\r\n            });\r\n        });\r\n\r\n        return returnData;\r\n    }\r\n\r\n    // End private functions\r\n\r\n    /**\r\n     * Creates and adds a new line of text\r\n     * @param line The properties of the line to be added\r\n     */\r\n    addLine(line: Omit<LineProps, 'ctx' | 'parent'>) {\r\n        const newLine = new Line({\r\n            ...line,\r\n            ctx: this.ctx,\r\n            parent: this,\r\n        });\r\n\r\n        this.lines.push(newLine);\r\n\r\n        return newLine;\r\n    }\r\n\r\n    removeLine(index?: number) {\r\n        const allLines = this.getLines();\r\n        if (index) {\r\n            const foundLine = allLines[index];\r\n\r\n            if (foundLine) {\r\n                this.lines = this.lines.filter(\r\n                    line => line.id !== foundLine.id\r\n                );\r\n                this.drawnLines = this.drawnLines.filter(\r\n                    line => line.id !== foundLine.id\r\n                );\r\n            } else {\r\n                // TODO: Show proper warning\r\n                //console.warn();\r\n            }\r\n        } else {\r\n            const toRemove = allLines[allLines.length - 1];\r\n\r\n            this.lines = this.lines.filter(line => line.id !== toRemove.id);\r\n            this.drawnLines = this.drawnLines.filter(\r\n                line => line.id !== toRemove.id\r\n            );\r\n        }\r\n    }\r\n\r\n    getCursorPosition(position: number) {\r\n        let textCharCount = 0;\r\n        let charId = -1;\r\n        this.text.forEach((textLine, index) => {\r\n            if (index < textCharCount + textLine.length) {\r\n                charId = this.text[index][position - textCharCount].id;\r\n            } else {\r\n                textCharCount += textLine.length;\r\n            }\r\n        });\r\n\r\n        if (charId > -1) {\r\n            const letter = this.getLetterByCharacterId(charId);\r\n\r\n            if (letter) {\r\n                const line = letter.getParent('line', letter) as Line;\r\n\r\n                const xPosition =\r\n                    line.x + (letter.x + letter.width) * this.scale;\r\n                const yPosition = line.y;\r\n\r\n                return {\r\n                    x: xPosition,\r\n                    y: yPosition,\r\n                };\r\n            } else {\r\n                console.warn('Letter not found');\r\n                return false;\r\n            }\r\n        } else {\r\n            console.warn('Character Not found');\r\n            return false;\r\n        }\r\n    }\r\n\r\n    addLetter({\r\n        letter,\r\n        position,\r\n    }: {\r\n        letter: string;\r\n        position: number | number[];\r\n    }) {\r\n        // let textBlock: string[] = [];\r\n        // if (Array.isArray(position) && Array.isArray(this.textItem.text)) {\r\n        //     textBlock[position[0]] = `${this.textItem.text[position[0]].slice(\r\n        //         0,\r\n        //         position[1]\r\n        //     )}${letter}${this.textItem.text[position[0]].slice(position[1])}`;\r\n        // } else {\r\n        //     if (typeof position === 'number') {\r\n        //         textBlock = [\r\n        //             `${this.textItem.text+\" \".slice(\r\n        //                 0,\r\n        //                 position\r\n        //             )}${letter}${this.textItem.text+\" \".slice(position)}`,\r\n        //         ];\r\n        //     }\r\n        // }\r\n\r\n        const newChar = new VaraChar({\r\n            char: letter,\r\n            fontItem:\r\n                this.root.fontCharacters[letter.charCodeAt(0)] ||\r\n                this.root.fontCharacters['63'],\r\n            isSpace: letter === ' ',\r\n        });\r\n\r\n        if (typeof position === 'number') {\r\n            let textCharCount = 0;\r\n            this.text.forEach((textLine, index) => {\r\n                if (position <= textCharCount + textLine.length) {\r\n                    this.text[index] = [\r\n                        ...textLine.slice(0, position - textCharCount),\r\n                        newChar,\r\n                        ...textLine.slice(position - textCharCount),\r\n                    ];\r\n                } else {\r\n                    textCharCount += textLine.length;\r\n                }\r\n            });\r\n        }\r\n\r\n        const lines = this.generateLineData(this.text);\r\n\r\n        if (lines.length > this.getLineCount()) {\r\n            while (lines.length > this.getLineCount()) {\r\n                this.addLine({\r\n                    x: 0,\r\n                    y: 0,\r\n                });\r\n            }\r\n        }\r\n\r\n        this.getLastLine().addLetter({\r\n            character: newChar,\r\n            width: newChar.fontItem.w,\r\n            x: 0,\r\n            y: 0,\r\n        });\r\n\r\n        this.regeneratePositions(lines);\r\n    }\r\n\r\n    removeLetter({ position }: { position: number | number[] }) {\r\n        let charId = -1;\r\n\r\n        if (typeof position === 'number') {\r\n            let textCharCount = 0;\r\n            this.text.forEach((textLine, index) => {\r\n                if (position <= textCharCount + textLine.length) {\r\n                    if (position <= textCharCount + textLine.length) {\r\n                        charId = this.text[index][position - textCharCount].id;\r\n                        this.text[index].splice(position - textCharCount, 1);\r\n                    } else {\r\n                        textCharCount += textLine.length;\r\n                    }\r\n                } else {\r\n                    textCharCount += textLine.length;\r\n                }\r\n            });\r\n        }\r\n\r\n        const lines = this.generateLineData(this.text);\r\n\r\n        if (lines.length < this.getLineCount()) {\r\n            while (lines.length < this.getLineCount()) {\r\n                this.removeLine();\r\n            }\r\n        }\r\n\r\n        const letter = this.getAllLetters().find(\r\n            item => item.character.getId() === charId\r\n        );\r\n\r\n        if (letter) {\r\n            const line = letter.getParent('line', letter);\r\n\r\n            if (line) {\r\n                line.removeLetter(letter.id);\r\n            }\r\n        }\r\n\r\n        this.regeneratePositions(lines);\r\n    }\r\n\r\n    getAllLetters() {\r\n        const letters = this.getLines().map(item => item.getAllLetters());\r\n        return letters.flat();\r\n    }\r\n\r\n    getLines() {\r\n        return [...this.lines, ...this.drawnLines];\r\n    }\r\n\r\n    getLineCount() {\r\n        return this.getLines().length;\r\n    }\r\n\r\n    getLineAtIndex(index: number) {\r\n        return this.getLines()[index];\r\n    }\r\n\r\n    getLastLine() {\r\n        const allLines = this.getLines();\r\n        return allLines[allLines.length - 1];\r\n    }\r\n\r\n    getLetterByCharacterId(id: number) {\r\n        return (\r\n            this.getAllLetters().find(item => item.character.id === id) ?? false\r\n        );\r\n    }\r\n\r\n    setRenderFunction(\r\n        fn: (ctx: CanvasRenderingContext2D, rafTime: number) => void\r\n    ) {\r\n        this.userDefinedRenderFn = fn;\r\n    }\r\n\r\n    updateOptions(options: VaraTextOptions) {\r\n        this.options = {\r\n            ...this.options,\r\n            ...options,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Remove the first line from the queue of lines. Used when a text line has been drawn completely.\r\n     *\r\n     * The removed item is moved to the drawnParts array\r\n     */\r\n    dequeue() {\r\n        const removedItem = this.lines.shift();\r\n        if (removedItem) this.drawnLines.push(removedItem);\r\n    }\r\n\r\n    /**\r\n     * Increment or decrement the total path length\r\n     * @param pathLength Path length that is to be incremented or decrement\r\n     * @param action Whether to increment or decrement\r\n     */\r\n    modifyPathLength(\r\n        pathLength: number,\r\n        action: 'increment' | 'decrement' = 'increment'\r\n    ) {\r\n        if (action === 'increment') {\r\n            this.totalPathLength += pathLength;\r\n        } else {\r\n            this.totalPathLength -= pathLength;\r\n        }\r\n        return this.totalPathLength;\r\n    }\r\n\r\n    /**\r\n     * Render the block\r\n     * @param rafTime The time value received from requestAnimationFrame\r\n     */\r\n    render(rafTime: number) {\r\n        if (this.previousRAFTime === 0) {\r\n            this.previousRAFTime = rafTime;\r\n        }\r\n\r\n        this.ctx.save();\r\n        this.ctx.translate(this.x, this.y);\r\n        this.ctx.strokeStyle = this.options.color;\r\n        this.ctx.lineWidth = this.options.strokeWidth;\r\n        this.ctx.lineCap = 'round';\r\n        this.ctx.lineJoin = 'round';\r\n\r\n        this.drawnLines.forEach(line => {\r\n            line.render(rafTime, this.previousRAFTime);\r\n        });\r\n\r\n        if (this.lines.length > 0) {\r\n            const line = this.lines[0];\r\n            if (line.isDone()) {\r\n                this.dequeue();\r\n            }\r\n            line.render(rafTime, this.previousRAFTime);\r\n        }\r\n        this.userDefinedRenderFn(this.ctx, rafTime);\r\n\r\n        this.ctx.restore();\r\n        this.previousRAFTime = rafTime;\r\n    }\r\n}\r\n","import {\r\n    VaraGeneralOptions,\r\n    VaraText,\r\n    VaraFontItem,\r\n    ObjectKeys,\r\n    VaraTextOptions,\r\n} from './types';\r\nimport Block from './utils/block';\r\n\r\nexport default class Vara {\r\n    elementName: string;\r\n    element: HTMLElement;\r\n    fontSource: string;\r\n    options: VaraGeneralOptions;\r\n    textItems: VaraText[];\r\n    blocks: Block[];\r\n    rendered: boolean;\r\n    defaultOptions: Required<VaraGeneralOptions>;\r\n    defaultCharacters: {\r\n        [x: string]: VaraFontItem;\r\n    };\r\n    canvas: HTMLCanvasElement;\r\n    ctx: CanvasRenderingContext2D;\r\n    canvasWidth: number;\r\n    contextHeight: number;\r\n    fontCharacters: {\r\n        [x: string]: VaraFontItem;\r\n    };\r\n    fontProperties!: {\r\n        s: number;\r\n        // TODO: add other properties\r\n        slc: 'round';\r\n        bsw: number;\r\n        lh: number;\r\n        space: number;\r\n        tf: number;\r\n    };\r\n    onDrawF?: () => void;\r\n    private readyfn?: () => void;\r\n\r\n    whitespace: number;\r\n    scalebase: number;\r\n\r\n    constructor(\r\n        elem: string,\r\n        fontSource: string,\r\n        text: VaraText[],\r\n        options: VaraGeneralOptions\r\n    ) {\r\n        this.elementName = elem;\r\n        this.element = document.querySelector(elem) as HTMLElement;\r\n        this.fontSource = fontSource;\r\n        this.options = options;\r\n        this.textItems = text;\r\n        this.blocks = [];\r\n        this.rendered = false;\r\n        this.fontCharacters = {};\r\n        this.canvasWidth = 0;\r\n\r\n        this.defaultOptions = {\r\n            fontSize: 21,\r\n            strokeWidth: 0.5,\r\n            color: '#000',\r\n            duration: 1000,\r\n            textAlign: 'left',\r\n            autoAnimation: true,\r\n            queued: true,\r\n            delay: 0,\r\n            breakWord: false,\r\n            letterSpacing: {\r\n                global: 0,\r\n            },\r\n            width: this.element.getBoundingClientRect().width,\r\n            lineHeight: 30,\r\n        };\r\n\r\n        this.defaultCharacters = {\r\n            '63': {\r\n                paths: [\r\n                    {\r\n                        w: 8.6437,\r\n                        h: 14.23173,\r\n                        my: 22.6665,\r\n                        mx: 0,\r\n                        dx: 0,\r\n                        d:\r\n                            'm 0,0 c -2,-6.01,5,-8.64,8,-3.98,2,4.09,-7,8.57,-7,11.85',\r\n                        pl: 1,\r\n                    },\r\n                    {\r\n                        w: 1.1037,\r\n                        h: 1.5498,\r\n                        my: 8.8815,\r\n                        dx: 0,\r\n                        mx: 1,\r\n                        d:\r\n                            'm 0,0 a 0.7592,0.7357,0,0,1,0,0.735,0.7592,0.7357,0,0,1,-1,-0.735,0.7592,0.7357,0,0,1,1,-0.738,0.7592,0.7357,0,0,1,0,0.738 z',\r\n                        pl: 1,\r\n                    },\r\n                ],\r\n                w: 8.6437,\r\n            },\r\n        };\r\n\r\n        this.canvas = document.createElement('canvas');\r\n        this.canvas.width = this.element.getBoundingClientRect().width;\r\n        this.canvas.height = 800;\r\n        this.ctx = this.canvas.getContext('2d') as CanvasRenderingContext2D;\r\n        this.element.appendChild(this.canvas);\r\n        this.whitespace = 10;\r\n        this.scalebase = 16;\r\n\r\n        this.contextHeight = 0;\r\n\r\n        this.init();\r\n    }\r\n\r\n    private init() {\r\n        this.normalizeOptions();\r\n\r\n        const xmlhttp = new XMLHttpRequest();\r\n        xmlhttp.open('GET', this.fontSource, true);\r\n        xmlhttp.onreadystatechange = () => {\r\n            if (xmlhttp.readyState === 4) {\r\n                if (xmlhttp.status === 200) {\r\n                    const contents = JSON.parse(xmlhttp.responseText);\r\n                    this.fontCharacters = contents.c;\r\n                    this.fontProperties = contents.p;\r\n                    this.preRender();\r\n                    if (this.readyfn) this.readyfn();\r\n                    this.render();\r\n                }\r\n            }\r\n        };\r\n        xmlhttp.send(null);\r\n    }\r\n\r\n    ready(fn: () => void) {\r\n        this.readyfn = fn;\r\n    }\r\n\r\n    onDraw(fn: () => void) {\r\n        this.onDrawF = fn;\r\n    }\r\n\r\n    /**\r\n     * Sets default option value for all existing option properties.\r\n     * If an option value is not provided, then it will first check if it is given in the global options, if not it will use the default option.\r\n     */\r\n    private normalizeOptions() {\r\n        this.options = this.options || {};\r\n\r\n        this.options = {\r\n            ...this.defaultOptions,\r\n            ...this.options,\r\n        };\r\n\r\n        Object.keys(this.defaultCharacters).forEach(character => {\r\n            if (this.fontCharacters[character] === undefined) {\r\n                this.fontCharacters[character] = this.defaultCharacters[\r\n                    character\r\n                ];\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Performs some actions before rendering starts. These include finding the pathLength of each path and generating the render data.\r\n     */\r\n    private preRender() {\r\n        // TODO: Cleanup all appended elements\r\n        let svg = this.createSVGNode('svg', {\r\n            width: '100',\r\n            height: '100',\r\n        });\r\n        svg.style.position = 'absolute';\r\n        svg.style.zIndex = '-100';\r\n        svg.style.opacity = '0';\r\n        svg.style.top = '0';\r\n\r\n        document.body.appendChild(svg);\r\n        let svgPathData = this.createSVGNode('path', {\r\n            d: '',\r\n        }) as SVGPathElement;\r\n        svg.appendChild(svgPathData);\r\n\r\n        this.setScaleBase();\r\n        this.setWhitespaceWidth();\r\n\r\n        if (this.fontCharacters['32'] === undefined) {\r\n            this.createWhitespaceLine();\r\n        }\r\n\r\n        this.objectKeys(this.fontCharacters).forEach(char => {\r\n            this.fontCharacters[char].paths.forEach((path, i) => {\r\n                svgPathData.setAttributeNS(null, 'd', path.d);\r\n                this.fontCharacters[char].paths[\r\n                    i\r\n                ].dx = svgPathData.getBoundingClientRect().x;\r\n                this.fontCharacters[char].paths[\r\n                    i\r\n                ].pl = svgPathData.getTotalLength();\r\n            });\r\n        });\r\n\r\n        this.textItems.forEach(item => {\r\n            const block = new Block({\r\n                root: this,\r\n                options: {\r\n                    ...(this.options as Required<VaraTextOptions>),\r\n                    ...item,\r\n                },\r\n                ctx: this.ctx,\r\n            });\r\n\r\n            this.blocks.push(block);\r\n        });\r\n    }\r\n\r\n    private createWhitespaceLine() {\r\n        const path = `m0,0 l0,0 ${this.whitespace},0`;\r\n        const fontItem: VaraFontItem = {\r\n            paths: [\r\n                {\r\n                    d: path,\r\n                    dx: 0,\r\n                    h: 1,\r\n                    mx: 0,\r\n                    my: 0,\r\n                    pl: this.whitespace,\r\n                    w: this.whitespace,\r\n                },\r\n            ],\r\n            w: this.whitespace,\r\n        };\r\n        this.fontCharacters['32'] = fontItem;\r\n    }\r\n\r\n    private render(rafTime = 0) {\r\n        let canvasHeight = this.calculateCanvasHeight();\r\n        if (canvasHeight !== this.canvas.height) {\r\n            this.canvas.height = canvasHeight;\r\n        }\r\n        this.ctx.clearRect(0, 0, this.canvas.width, canvasHeight);\r\n\r\n        this.blocks.forEach(item => {\r\n            item.render(rafTime);\r\n        });\r\n\r\n        window.requestAnimationFrame(time => this.render(time));\r\n    }\r\n\r\n    // TODO: Make proper calculation function.\r\n    calculateCanvasHeight() {\r\n        let height = 0;\r\n        this.blocks.forEach(item => {\r\n            if (item.height && item.options.y) {\r\n                height += item.height + item.options.y;\r\n            }\r\n        });\r\n        return height + 50;\r\n    }\r\n\r\n    addLetter({\r\n        letter,\r\n        id,\r\n        position,\r\n    }: {\r\n        letter: string;\r\n        id: string;\r\n        position: number;\r\n    }) {\r\n        const block = this.getBlock(id);\r\n        if (block) {\r\n            block.addLetter({ letter, position });\r\n            return true;\r\n        } else {\r\n            console.warn(`Block with id ${id} not found`);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    removeLetter({ id, position }: { id: string; position: number }) {\r\n        const block = this.getBlock(id);\r\n\r\n        if (block) {\r\n            block.removeLetter({ position });\r\n            return true;\r\n        } else {\r\n            console.warn(`Block with id ${id} not found`);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    getCursorPosition({ position, id }: { position: number; id: string }) {\r\n        const block = this.getBlock(id);\r\n\r\n        if (block) {\r\n            return block.getCursorPosition(position);\r\n        } else {\r\n            console.warn(`Block with id ${id} not found`);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    setRenderFunction(id: string, fn: (ctx: CanvasRenderingContext2D) => void) {\r\n        const block = this.getBlock(id);\r\n        if (block) {\r\n            return block.setRenderFunction(fn);\r\n        } else {\r\n            console.warn(`Block with id ${id} not found`);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    getBlock(id: string) {\r\n        return this.blocks.find(item => item.options.id === id) ?? false;\r\n    }\r\n\r\n    /**\r\n     * Creates and returns an SVG element\r\n     * @param n The name of the SVG node to be created\r\n     * @param v The attributes of the node\r\n     */\r\n\r\n    createSVGNode(n: string, v: { [x: string]: string }) {\r\n        const e = document.createElementNS('http://www.w3.org/2000/svg', n);\r\n        for (var p in v)\r\n            e.setAttributeNS(\r\n                null,\r\n                p.replace(/[A-Z]/g, function(m) {\r\n                    return '-' + m.toLowerCase();\r\n                }),\r\n                v[p]\r\n            );\r\n        return e;\r\n    }\r\n\r\n    private setScaleBase() {\r\n        const charCode = this.fontCharacters['97']\r\n            ? '97'\r\n            : Object.keys(this.fontCharacters)[0];\r\n        const psuedoText = this.fontCharacters[charCode];\r\n\r\n        const psuedoTextElement = document.createElement('span');\r\n        psuedoTextElement.setAttribute('style', 'position:absolute;opacity:0;');\r\n        psuedoTextElement.textContent = String.fromCharCode(parseInt(charCode));\r\n\r\n        this.element.appendChild(psuedoTextElement);\r\n\r\n        const psuedoTextElementWidth = psuedoTextElement.clientWidth;\r\n        this.scalebase = psuedoTextElementWidth / psuedoText.w;\r\n        console.log(psuedoTextElementWidth, psuedoText.w);\r\n\r\n        this.element.removeChild(psuedoTextElement);\r\n    }\r\n\r\n    private setWhitespaceWidth() {\r\n        const psuedoTextElement = document.createElement('span');\r\n        psuedoTextElement.setAttribute('style', 'position:absolute;opacity:0;');\r\n        psuedoTextElement.innerHTML = '&nbsp;';\r\n\r\n        this.element.appendChild(psuedoTextElement);\r\n        const psuedoTextElementWidth = psuedoTextElement.clientWidth;\r\n        this.whitespace = psuedoTextElementWidth / this.scalebase;\r\n        this.element.removeChild(psuedoTextElement);\r\n    }\r\n\r\n    /**\r\n     * Modifies the move to command of a given path and returns it.\r\n     * @param path The path \"d\" property\r\n     * @param x The x co-ordinate\r\n     * @param y The y co-ordinate\r\n     */\r\n    processPath(path: string, x = 0, y = 0) {\r\n        let svgPath = path.split('');\r\n        svgPath[2] = x + 1 + '';\r\n        svgPath[4] = y + '';\r\n        return svgPath.join('');\r\n    }\r\n\r\n    objectKeys<T>(x: T) {\r\n        let keys = Object.keys(x) as ObjectKeys<T>;\r\n        return keys;\r\n    }\r\n\r\n    boundRect(x: number, y: number, w: number, h = 10) {\r\n        this.ctx.save();\r\n        this.ctx.fillStyle = 'rgba(209, 56, 61,0.4)';\r\n        this.ctx.fillRect(x, y, w, h);\r\n        this.ctx.fill();\r\n        this.ctx.restore();\r\n    }\r\n}\r\n\r\nif (window) {\r\n    (window as any).Vara = Vara;\r\n}\r\n"],"names":["varaCharId","VaraChar","props","fontItem","isSpace","id","getFontItem","this","getId","BLOCK_COMPOSITION","RenderBase","ctx","parent","name","getParent","parentName","current","indexOf","LetterPart","x","y","path","pathLength","dashOffset","width","rootBlock","_this","paint","save","stroke","Path2D","processPath","restore","draw","delta","speed","totalPathLength","options","duration","lineDashOffset","setLineDash","svgPath","split","join","letterId","Letter","parts","drawnParts","character","setPosition","addPart","part","push","modifyPathLength","setParent","isDone","length","dequeue","removedItem","shift","render","rafTime","previousRAFTime","scale","translate","forEach","drawnPart","lineId","Line","letters","drawnLetters","addLetter","letter","newLetter","paths","d","mx","dx","my","pl","w","removeLetter","filter","setLetters","getAllLetters","prevRAFTime","currentLetter","Block","height","lines","drawnLines","text","root","Math","min","fontSize","scalebase","userDefinedRenderFn","initTextToVaraChar","generatePositions","map","_this2","fontCharacters","charCodeAt","Array","isArray","line","regeneratePositions","top","lineHeight","lettersToSetInLine","lineIndex","left","_this3","textAlign","lineClass","getLineAtIndex","lettersToSet","char","foundLetter","getLetterByCharacterId","console","error","getLines","generateLineData","_this4","addLine","returnData","wordSplittedLines","l","spaceWidth","word","wordWidth","pathPositionCorrection","reduce","a","c","_this5","spaceChar","_returnData","newLine","removeLine","index","allLines","foundLine","toRemove","getCursorPosition","position","textCharCount","charId","textLine","_this6","warn","newChar","_this7","slice","getLineCount","getLastLine","_this8","splice","find","item","flat","setRenderFunction","fn","updateOptions","action","strokeStyle","color","lineWidth","strokeWidth","lineCap","lineJoin","_this9","Vara","elem","fontSource","elementName","element","document","querySelector","textItems","blocks","rendered","canvasWidth","defaultOptions","autoAnimation","queued","delay","breakWord","letterSpacing","global","getBoundingClientRect","defaultCharacters","h","canvas","createElement","getContext","appendChild","whitespace","contextHeight","init","normalizeOptions","xmlhttp","XMLHttpRequest","open","onreadystatechange","readyState","status","contents","JSON","parse","responseText","fontProperties","p","preRender","readyfn","send","ready","onDraw","onDrawF","Object","keys","undefined","svg","createSVGNode","style","zIndex","opacity","body","svgPathData","setScaleBase","setWhitespaceWidth","createWhitespaceLine","objectKeys","i","setAttributeNS","getTotalLength","block","canvasHeight","calculateCanvasHeight","clearRect","window","requestAnimationFrame","time","getBlock","n","v","e","createElementNS","replace","m","toLowerCase","charCode","psuedoText","psuedoTextElement","setAttribute","textContent","String","fromCharCode","parseInt","psuedoTextElementWidth","clientWidth","log","removeChild","innerHTML","boundRect","fillStyle","fillRect","fill"],"mappings":"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"}